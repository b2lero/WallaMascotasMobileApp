/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.4.0 (NJsonSchema v9.13.36.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class ApiWmClientService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param userIds (optional) 
     * @param fromUtcDate (optional) 
     * @param toUtcDate (optional) 
     * @return Success
     */
    getAccesses(userIds: number[] | undefined, fromUtcDate: Date | undefined, toUtcDate: Date | undefined): Observable<AccessesPage> {
        let url_ = this.baseUrl + "/api/accessess?";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromUtcDate === null)
            throw new Error("The parameter 'fromUtcDate' cannot be null.");
        else if (fromUtcDate !== undefined)
            url_ += "fromUtcDate=" + encodeURIComponent(fromUtcDate ? "" + fromUtcDate.toJSON() : "") + "&"; 
        if (toUtcDate === null)
            throw new Error("The parameter 'toUtcDate' cannot be null.");
        else if (toUtcDate !== undefined)
            url_ += "toUtcDate=" + encodeURIComponent(toUtcDate ? "" + toUtcDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccesses(<any>response_);
                } catch (e) {
                    return <Observable<AccessesPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessesPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccesses(response: HttpResponseBase): Observable<AccessesPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessesPage.fromJS(resultData200) : new AccessesPage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessesPage>(<any>null);
    }

    /**
     * @param userIds (optional) 
     * @param fromUtcDate (optional) 
     * @param toUtcDate (optional) 
     * @return Success
     */
    deleteAccesses(userIds: number[] | undefined, fromUtcDate: Date | undefined, toUtcDate: Date | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/accessess?";
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        if (fromUtcDate === null)
            throw new Error("The parameter 'fromUtcDate' cannot be null.");
        else if (fromUtcDate !== undefined)
            url_ += "fromUtcDate=" + encodeURIComponent(fromUtcDate ? "" + fromUtcDate.toJSON() : "") + "&"; 
        if (toUtcDate === null)
            throw new Error("The parameter 'toUtcDate' cannot be null.");
        else if (toUtcDate !== undefined)
            url_ += "toUtcDate=" + encodeURIComponent(toUtcDate ? "" + toUtcDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccesses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccesses(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccesses(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAccess(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/accessess/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccess(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccess(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccess(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getAssociationLikes(id: number): Observable<AssociationLike[]> {
        let url_ = this.baseUrl + "/api/associations/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociationLikes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociationLikes(<any>response_);
                } catch (e) {
                    return <Observable<AssociationLike[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssociationLike[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssociationLikes(response: HttpResponseBase): Observable<AssociationLike[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssociationLike.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssociationLike[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAssociationLike(id: number, body: AssociationLike | undefined): Observable<AssociationLike> {
        let url_ = this.baseUrl + "/api/associations/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAssociationLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAssociationLike(<any>response_);
                } catch (e) {
                    return <Observable<AssociationLike>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssociationLike>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAssociationLike(response: HttpResponseBase): Observable<AssociationLike> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociationLike.fromJS(resultData200) : new AssociationLike();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssociationLike>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAssociationLike(id: number, associationLikeId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/associations/{id}/likes/{associationLikeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (associationLikeId === undefined || associationLikeId === null)
            throw new Error("The parameter 'associationLikeId' must be defined.");
        url_ = url_.replace("{associationLikeId}", encodeURIComponent("" + associationLikeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssociationLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssociationLike(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssociationLike(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Associations
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param location (optional) 
     * @param countryIds (optional) 
     * @param regionIds (optional) 
     * @return Success
     */
    getAssociations(page: number | undefined, pageSize: number | undefined, name: string | undefined, location: string | undefined, countryIds: number[] | undefined, regionIds: number[] | undefined): Observable<AssociationsPage> {
        let url_ = this.baseUrl + "/api/associations?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "countryIds=" + encodeURIComponent("" + item) + "&"; });
        if (regionIds === null)
            throw new Error("The parameter 'regionIds' cannot be null.");
        else if (regionIds !== undefined)
            regionIds && regionIds.forEach(item => { url_ += "regionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociations(<any>response_);
                } catch (e) {
                    return <Observable<AssociationsPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssociationsPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssociations(response: HttpResponseBase): Observable<AssociationsPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociationsPage.fromJS(resultData200) : new AssociationsPage();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssociationsPage>(<any>null);
    }

    /**
     * Saves an Association
     * @param body (optional) 
     * @return Success
     */
    createAssociation(body: Association | undefined): Observable<Association> {
        let url_ = this.baseUrl + "/api/associations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAssociation(<any>response_);
                } catch (e) {
                    return <Observable<Association>><any>_observableThrow(e);
                }
            } else
                return <Observable<Association>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAssociation(response: HttpResponseBase): Observable<Association> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Association.fromJS(resultData200) : new Association();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Association>(<any>null);
    }

    /**
     * Retrieves a specific Association
     * @param id Association Id
     * @return Success
     */
    getAssociation(id: number): Observable<Association> {
        let url_ = this.baseUrl + "/api/associations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociation(<any>response_);
                } catch (e) {
                    return <Observable<Association>><any>_observableThrow(e);
                }
            } else
                return <Observable<Association>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssociation(response: HttpResponseBase): Observable<Association> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Association.fromJS(resultData200) : new Association();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Association>(<any>null);
    }

    /**
     * Updates an Association
     * @param id Association Id
     * @param body (optional) 
     * @return Success
     */
    updateAssociation(id: number, body: Association | undefined): Observable<Association> {
        let url_ = this.baseUrl + "/api/associations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAssociation(<any>response_);
                } catch (e) {
                    return <Observable<Association>><any>_observableThrow(e);
                }
            } else
                return <Observable<Association>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAssociation(response: HttpResponseBase): Observable<Association> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Association.fromJS(resultData200) : new Association();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Association>(<any>null);
    }

    /**
     * Deletes an Association
     * @param id Association Id
     * @return Success
     */
    deleteAssociation(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/associations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssociation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssociation(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssociation(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getAssociationVisits(id: number): Observable<AssociationVisit[]> {
        let url_ = this.baseUrl + "/api/associations/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssociationVisits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssociationVisits(<any>response_);
                } catch (e) {
                    return <Observable<AssociationVisit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssociationVisit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssociationVisits(response: HttpResponseBase): Observable<AssociationVisit[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AssociationVisit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssociationVisit[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createAssociationVisit(id: number, body: AssociationVisit | undefined): Observable<AssociationVisit> {
        let url_ = this.baseUrl + "/api/associations/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateAssociationVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateAssociationVisit(<any>response_);
                } catch (e) {
                    return <Observable<AssociationVisit>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssociationVisit>><any>_observableThrow(response_);
        }));
    }

    protected processCreateAssociationVisit(response: HttpResponseBase): Observable<AssociationVisit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AssociationVisit.fromJS(resultData200) : new AssociationVisit();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssociationVisit>(<any>null);
    }

    /**
     * @return Success
     */
    deleteAssociationVisit(id: number, associationVisitId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/associations/{id}/visits/{associationVisitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (associationVisitId === undefined || associationVisitId === null)
            throw new Error("The parameter 'associationVisitId' must be defined.");
        url_ = url_.replace("{associationVisitId}", encodeURIComponent("" + associationVisitId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAssociationVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAssociationVisit(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAssociationVisit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getCountries(): Observable<Country[]> {
        let url_ = this.baseUrl + "/api/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Country.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }

    /**
     * @return Success
     */
    getCountryRegions(id: number): Observable<Region[]> {
        let url_ = this.baseUrl + "/api/countries/{id}/regions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountryRegions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountryRegions(<any>response_);
                } catch (e) {
                    return <Observable<Region[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Region[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountryRegions(response: HttpResponseBase): Observable<Region[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Region.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Region[]>(<any>null);
    }

    /**
     * @return Success
     */
    getFunctions(): Observable<Function[]> {
        let url_ = this.baseUrl + "/api/functions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFunctions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFunctions(<any>response_);
                } catch (e) {
                    return <Observable<Function[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Function[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFunctions(response: HttpResponseBase): Observable<Function[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Function.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Function[]>(<any>null);
    }

    /**
     * @return Success
     */
    getPetCategories(): Observable<PetCategory[]> {
        let url_ = this.baseUrl + "/api/pet-categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPetCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPetCategories(<any>response_);
                } catch (e) {
                    return <Observable<PetCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPetCategories(response: HttpResponseBase): Observable<PetCategory[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetCategory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetCategory[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPetCategory(body: PetCategory | undefined): Observable<PetCategory> {
        let url_ = this.baseUrl + "/api/pet-categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePetCategory(<any>response_);
                } catch (e) {
                    return <Observable<PetCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetCategory>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePetCategory(response: HttpResponseBase): Observable<PetCategory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetCategory.fromJS(resultData200) : new PetCategory();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetCategory>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePetCategory(id: number, body: PetCategory | undefined): Observable<PetCategory> {
        let url_ = this.baseUrl + "/api/pet-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePetCategory(<any>response_);
                } catch (e) {
                    return <Observable<PetCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetCategory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePetCategory(response: HttpResponseBase): Observable<PetCategory> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetCategory.fromJS(resultData200) : new PetCategory();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetCategory>(<any>null);
    }

    /**
     * @return Success
     */
    deletePetCategory(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pet-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetCategory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePetCategory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Contacts registered in a Pet
     * @param id Pet Id
     * @return Success
     */
    getPetContacts(id: number): Observable<PetContact[]> {
        let url_ = this.baseUrl + "/api/pets/{id}/contacts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPetContacts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPetContacts(<any>response_);
                } catch (e) {
                    return <Observable<PetContact[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetContact[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPetContacts(response: HttpResponseBase): Observable<PetContact[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetContact.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetContact[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPetContact(id: number, body: PetContact | undefined): Observable<PetContact> {
        let url_ = this.baseUrl + "/api/pets/{id}/contacts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePetContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePetContact(<any>response_);
                } catch (e) {
                    return <Observable<PetContact>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetContact>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePetContact(response: HttpResponseBase): Observable<PetContact> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetContact.fromJS(resultData200) : new PetContact();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetContact>(<any>null);
    }

    /**
     * @return Success
     */
    deletePetContact(id: number, petContactId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pets/{id}/contacts/{petContactId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (petContactId === undefined || petContactId === null)
            throw new Error("The parameter 'petContactId' must be defined.");
        url_ = url_.replace("{petContactId}", encodeURIComponent("" + petContactId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetContact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetContact(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePetContact(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Likes given to a Pet
     * @param id Pet Id
     * @return Success
     */
    getPetLikes(id: number): Observable<PetLike[]> {
        let url_ = this.baseUrl + "/api/pets/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPetLikes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPetLikes(<any>response_);
                } catch (e) {
                    return <Observable<PetLike[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetLike[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPetLikes(response: HttpResponseBase): Observable<PetLike[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetLike.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetLike[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPetLike(id: number, body: PetLike | undefined): Observable<PetLike> {
        let url_ = this.baseUrl + "/api/pets/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePetLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePetLike(<any>response_);
                } catch (e) {
                    return <Observable<PetLike>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetLike>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePetLike(response: HttpResponseBase): Observable<PetLike> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetLike.fromJS(resultData200) : new PetLike();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetLike>(<any>null);
    }

    /**
     * @return Success
     */
    deletePetLike(id: number, petLikeId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pets/{id}/likes/{petLikeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (petLikeId === undefined || petLikeId === null)
            throw new Error("The parameter 'petLikeId' must be defined.");
        url_ = url_.replace("{petLikeId}", encodeURIComponent("" + petLikeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetLike(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePetLike(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Pets
     * @param page (optional) Page number. Default value: 1
     * @param pageSize (optional) Page size. Default value: 100
     * @param name (optional) Pet name filter. Will only retrieve Pets whose name contains this value
     * @param minAge (optional) Minimum age filter. Minimum value: 0. Maximum value: 100
     * @param maxAge (optional) Maximum age filter. Minimum value: 0. Maximum value: 100
     * @param breed (optional) 
     * @param location (optional) 
     * @param fromCreationDate (optional) 
     * @param toCreationDate (optional) 
     * @param fromUpdateDate (optional) 
     * @param toUpdateDate (optional) 
     * @param publicationStatusIds (optional) 
     * @param petTypeIds (optional) Pet Types filter. GET api/pet-types for Ids
     * @param petCategoryIds (optional) Categories filter. GET api/pet-categories for Ids
     * @param countryIds (optional) Countries filter. GET api/countries for Ids
     * @param regionIds (optional) 
     * @param associationIds (optional) 
     * @param userIds (optional) 
     * @return Success
     */
    getPets(page: number | undefined, pageSize: number | undefined, name: string | undefined, minAge: number | undefined, maxAge: number | undefined, breed: string | undefined, location: string | undefined, fromCreationDate: Date | undefined, toCreationDate: Date | undefined, fromUpdateDate: Date | undefined, toUpdateDate: Date | undefined, publicationStatusIds: number[] | undefined, petTypeIds: number[] | undefined, petCategoryIds: number[] | undefined, countryIds: number[] | undefined, regionIds: number[] | undefined, associationIds: number[] | undefined, userIds: number[] | undefined): Observable<PetsPage> {
        let url_ = this.baseUrl + "/api/pets?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (minAge === null)
            throw new Error("The parameter 'minAge' cannot be null.");
        else if (minAge !== undefined)
            url_ += "minAge=" + encodeURIComponent("" + minAge) + "&"; 
        if (maxAge === null)
            throw new Error("The parameter 'maxAge' cannot be null.");
        else if (maxAge !== undefined)
            url_ += "maxAge=" + encodeURIComponent("" + maxAge) + "&"; 
        if (breed === null)
            throw new Error("The parameter 'breed' cannot be null.");
        else if (breed !== undefined)
            url_ += "breed=" + encodeURIComponent("" + breed) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (fromCreationDate === null)
            throw new Error("The parameter 'fromCreationDate' cannot be null.");
        else if (fromCreationDate !== undefined)
            url_ += "fromCreationDate=" + encodeURIComponent(fromCreationDate ? "" + fromCreationDate.toJSON() : "") + "&"; 
        if (toCreationDate === null)
            throw new Error("The parameter 'toCreationDate' cannot be null.");
        else if (toCreationDate !== undefined)
            url_ += "toCreationDate=" + encodeURIComponent(toCreationDate ? "" + toCreationDate.toJSON() : "") + "&"; 
        if (fromUpdateDate === null)
            throw new Error("The parameter 'fromUpdateDate' cannot be null.");
        else if (fromUpdateDate !== undefined)
            url_ += "fromUpdateDate=" + encodeURIComponent(fromUpdateDate ? "" + fromUpdateDate.toJSON() : "") + "&"; 
        if (toUpdateDate === null)
            throw new Error("The parameter 'toUpdateDate' cannot be null.");
        else if (toUpdateDate !== undefined)
            url_ += "toUpdateDate=" + encodeURIComponent(toUpdateDate ? "" + toUpdateDate.toJSON() : "") + "&"; 
        if (publicationStatusIds === null)
            throw new Error("The parameter 'publicationStatusIds' cannot be null.");
        else if (publicationStatusIds !== undefined)
            publicationStatusIds && publicationStatusIds.forEach(item => { url_ += "publicationStatusIds=" + encodeURIComponent("" + item) + "&"; });
        if (petTypeIds === null)
            throw new Error("The parameter 'petTypeIds' cannot be null.");
        else if (petTypeIds !== undefined)
            petTypeIds && petTypeIds.forEach(item => { url_ += "petTypeIds=" + encodeURIComponent("" + item) + "&"; });
        if (petCategoryIds === null)
            throw new Error("The parameter 'petCategoryIds' cannot be null.");
        else if (petCategoryIds !== undefined)
            petCategoryIds && petCategoryIds.forEach(item => { url_ += "petCategoryIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "countryIds=" + encodeURIComponent("" + item) + "&"; });
        if (regionIds === null)
            throw new Error("The parameter 'regionIds' cannot be null.");
        else if (regionIds !== undefined)
            regionIds && regionIds.forEach(item => { url_ += "regionIds=" + encodeURIComponent("" + item) + "&"; });
        if (associationIds === null)
            throw new Error("The parameter 'associationIds' cannot be null.");
        else if (associationIds !== undefined)
            associationIds && associationIds.forEach(item => { url_ += "associationIds=" + encodeURIComponent("" + item) + "&"; });
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPets(<any>response_);
                } catch (e) {
                    return <Observable<PetsPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetsPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetPets(response: HttpResponseBase): Observable<PetsPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetsPage.fromJS(resultData200) : new PetsPage();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetsPage>(<any>null);
    }

    /**
     * Saves a Pet
     * @param body (optional) 
     * @return Success
     */
    createPet(body: Pet | undefined): Observable<Pet> {
        let url_ = this.baseUrl + "/api/pets";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePet(<any>response_);
                } catch (e) {
                    return <Observable<Pet>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pet>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePet(response: HttpResponseBase): Observable<Pet> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Pet.fromJS(resultData200) : new Pet();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pet>(<any>null);
    }

    /**
     * @return Success
     */
    getPet(id: number): Observable<Pet> {
        let url_ = this.baseUrl + "/api/pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPet(<any>response_);
                } catch (e) {
                    return <Observable<Pet>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pet>><any>_observableThrow(response_);
        }));
    }

    protected processGetPet(response: HttpResponseBase): Observable<Pet> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Pet.fromJS(resultData200) : new Pet();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pet>(<any>null);
    }

    /**
     * Updates a Pet
     * @param id Pet Id
     * @param body (optional) 
     * @return Success
     */
    updatePet(id: number, body: Pet | undefined): Observable<Pet> {
        let url_ = this.baseUrl + "/api/pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePet(<any>response_);
                } catch (e) {
                    return <Observable<Pet>><any>_observableThrow(e);
                }
            } else
                return <Observable<Pet>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePet(response: HttpResponseBase): Observable<Pet> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Pet.fromJS(resultData200) : new Pet();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Pet>(<any>null);
    }

    /**
     * Deletes a Pet
     * @param id Pet Id
     * @return Success
     */
    deletePet(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pets/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePet(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePet(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getPetTypes(): Observable<PetType[]> {
        let url_ = this.baseUrl + "/api/pet-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPetTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPetTypes(<any>response_);
                } catch (e) {
                    return <Observable<PetType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPetTypes(response: HttpResponseBase): Observable<PetType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PetType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetType[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPetType(body: PetType | undefined): Observable<PetType> {
        let url_ = this.baseUrl + "/api/pet-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePetType(<any>response_);
                } catch (e) {
                    return <Observable<PetType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetType>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePetType(response: HttpResponseBase): Observable<PetType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetType.fromJS(resultData200) : new PetType();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetType>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePetType(id: number, body: PetType | undefined): Observable<PetType> {
        let url_ = this.baseUrl + "/api/pet-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePetType(<any>response_);
                } catch (e) {
                    return <Observable<PetType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePetType(response: HttpResponseBase): Observable<PetType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetType.fromJS(resultData200) : new PetType();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetType>(<any>null);
    }

    /**
     * @return Success
     */
    deletePetType(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pet-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetType(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePetType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Visits in a Pet
     * @param id Pet Id
     * @return Success
     */
    getPetVisits(id: number): Observable<PetVisit> {
        let url_ = this.baseUrl + "/api/pets/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPetVisits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPetVisits(<any>response_);
                } catch (e) {
                    return <Observable<PetVisit>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetVisit>><any>_observableThrow(response_);
        }));
    }

    protected processGetPetVisits(response: HttpResponseBase): Observable<PetVisit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetVisit.fromJS(resultData200) : new PetVisit();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetVisit>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPetVisit(id: number, body: PetVisit | undefined): Observable<PetVisit> {
        let url_ = this.baseUrl + "/api/pets/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePetVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePetVisit(<any>response_);
                } catch (e) {
                    return <Observable<PetVisit>><any>_observableThrow(e);
                }
            } else
                return <Observable<PetVisit>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePetVisit(response: HttpResponseBase): Observable<PetVisit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PetVisit.fromJS(resultData200) : new PetVisit();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PetVisit>(<any>null);
    }

    /**
     * @return Success
     */
    deletePetVisit(id: number, petVisitId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/pets/{id}/visits/{petVisitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (petVisitId === undefined || petVisitId === null)
            throw new Error("The parameter 'petVisitId' must be defined.");
        url_ = url_.replace("{petVisitId}", encodeURIComponent("" + petVisitId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePetVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePetVisit(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePetVisit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getProfessionalServiceLikes(id: number): Observable<ProfessionalServiceLike[]> {
        let url_ = this.baseUrl + "/api/professional-services/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalServiceLikes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalServiceLikes(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceLike[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceLike[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalServiceLikes(response: HttpResponseBase): Observable<ProfessionalServiceLike[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProfessionalServiceLike.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceLike[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfessionalServiceLike(id: number, body: ProfessionalServiceLike | undefined): Observable<ProfessionalServiceLike> {
        let url_ = this.baseUrl + "/api/professional-services/{id}/likes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfessionalServiceLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfessionalServiceLike(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceLike>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceLike>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfessionalServiceLike(response: HttpResponseBase): Observable<ProfessionalServiceLike> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalServiceLike.fromJS(resultData200) : new ProfessionalServiceLike();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceLike>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProfessionalServiceLike(id: number, professionalServiceLikeId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/professional-services/{id}/likes/{professionalServiceLikeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (professionalServiceLikeId === undefined || professionalServiceLikeId === null)
            throw new Error("The parameter 'professionalServiceLikeId' must be defined.");
        url_ = url_.replace("{professionalServiceLikeId}", encodeURIComponent("" + professionalServiceLikeId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfessionalServiceLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfessionalServiceLike(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfessionalServiceLike(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Retrieves all Professional Services
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param location (optional) 
     * @param userIds (optional) 
     * @param associationIds (optional) 
     * @param countryIds (optional) 
     * @param regionIds (optional) 
     * @param publicationStatusIds (optional) 
     * @param typeIds (optional) 
     * @return Success
     */
    getProfessionalServices(page: number | undefined, pageSize: number | undefined, name: string | undefined, location: string | undefined, userIds: number[] | undefined, associationIds: number[] | undefined, countryIds: number[] | undefined, regionIds: number[] | undefined, publicationStatusIds: number[] | undefined, typeIds: number[] | undefined): Observable<ProfessionalServicesPage> {
        let url_ = this.baseUrl + "/api/professional-services?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (userIds === null)
            throw new Error("The parameter 'userIds' cannot be null.");
        else if (userIds !== undefined)
            userIds && userIds.forEach(item => { url_ += "userIds=" + encodeURIComponent("" + item) + "&"; });
        if (associationIds === null)
            throw new Error("The parameter 'associationIds' cannot be null.");
        else if (associationIds !== undefined)
            associationIds && associationIds.forEach(item => { url_ += "associationIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "countryIds=" + encodeURIComponent("" + item) + "&"; });
        if (regionIds === null)
            throw new Error("The parameter 'regionIds' cannot be null.");
        else if (regionIds !== undefined)
            regionIds && regionIds.forEach(item => { url_ += "regionIds=" + encodeURIComponent("" + item) + "&"; });
        if (publicationStatusIds === null)
            throw new Error("The parameter 'publicationStatusIds' cannot be null.");
        else if (publicationStatusIds !== undefined)
            publicationStatusIds && publicationStatusIds.forEach(item => { url_ += "publicationStatusIds=" + encodeURIComponent("" + item) + "&"; });
        if (typeIds === null)
            throw new Error("The parameter 'typeIds' cannot be null.");
        else if (typeIds !== undefined)
            typeIds && typeIds.forEach(item => { url_ += "typeIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalServices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalServices(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServicesPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServicesPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalServices(response: HttpResponseBase): Observable<ProfessionalServicesPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalServicesPage.fromJS(resultData200) : new ProfessionalServicesPage();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServicesPage>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfessionalService(body: ProfessionalService | undefined): Observable<ProfessionalService> {
        let url_ = this.baseUrl + "/api/professional-services";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfessionalService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfessionalService(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalService>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalService>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfessionalService(response: HttpResponseBase): Observable<ProfessionalService> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalService.fromJS(resultData200) : new ProfessionalService();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalService>(<any>null);
    }

    /**
     * @return Success
     */
    getProfessionalService(id: number): Observable<ProfessionalService> {
        let url_ = this.baseUrl + "/api/professional-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalService(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalService>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalService>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalService(response: HttpResponseBase): Observable<ProfessionalService> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalService.fromJS(resultData200) : new ProfessionalService();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalService>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfessionalService(id: number, body: ProfessionalService | undefined): Observable<ProfessionalService> {
        let url_ = this.baseUrl + "/api/professional-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfessionalService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfessionalService(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalService>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalService>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfessionalService(response: HttpResponseBase): Observable<ProfessionalService> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalService.fromJS(resultData200) : new ProfessionalService();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalService>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProfessionalService(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/professional-services/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfessionalService(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfessionalService(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfessionalService(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getProfessionalServiceTypes(): Observable<ProfessionalServiceType[]> {
        let url_ = this.baseUrl + "/api/professional-service-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalServiceTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalServiceTypes(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalServiceTypes(response: HttpResponseBase): Observable<ProfessionalServiceType[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProfessionalServiceType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceType[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfessionalServiceType(body: ProfessionalServiceType | undefined): Observable<ProfessionalServiceType> {
        let url_ = this.baseUrl + "/api/professional-service-types";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfessionalServiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfessionalServiceType(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfessionalServiceType(response: HttpResponseBase): Observable<ProfessionalServiceType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalServiceType.fromJS(resultData200) : new ProfessionalServiceType();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceType>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfessionalServiceType(id: number, body: ProfessionalServiceType | undefined): Observable<ProfessionalServiceType> {
        let url_ = this.baseUrl + "/api/professional-service-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfessionalServiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfessionalServiceType(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceType>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfessionalServiceType(response: HttpResponseBase): Observable<ProfessionalServiceType> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalServiceType.fromJS(resultData200) : new ProfessionalServiceType();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceType>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProfessionalServiceType(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/professional-service-types/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfessionalServiceType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfessionalServiceType(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfessionalServiceType(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getProfessionalServiceVisits(id: number): Observable<ProfessionalServiceVisit[]> {
        let url_ = this.baseUrl + "/api/professional-service/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfessionalServiceVisits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfessionalServiceVisits(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceVisit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceVisit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfessionalServiceVisits(response: HttpResponseBase): Observable<ProfessionalServiceVisit[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProfessionalServiceVisit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceVisit[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProfessionalServiceVisit(id: number, body: ProfessionalServiceVisit | undefined): Observable<ProfessionalServiceVisit> {
        let url_ = this.baseUrl + "/api/professional-service/{id}/visits";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProfessionalServiceVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProfessionalServiceVisit(<any>response_);
                } catch (e) {
                    return <Observable<ProfessionalServiceVisit>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProfessionalServiceVisit>><any>_observableThrow(response_);
        }));
    }

    protected processCreateProfessionalServiceVisit(response: HttpResponseBase): Observable<ProfessionalServiceVisit> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ProfessionalServiceVisit.fromJS(resultData200) : new ProfessionalServiceVisit();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProfessionalServiceVisit>(<any>null);
    }

    /**
     * @return Success
     */
    deleteProfessionalServiceVisit(id: number, professionalServiceVisitId: number): Observable<any> {
        let url_ = this.baseUrl + "/api/professional-service/{id}/visits/{professionalServiceVisitId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (professionalServiceVisitId === undefined || professionalServiceVisitId === null)
            throw new Error("The parameter 'professionalServiceVisitId' must be defined.");
        url_ = url_.replace("{professionalServiceVisitId}", encodeURIComponent("" + professionalServiceVisitId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfessionalServiceVisit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfessionalServiceVisit(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfessionalServiceVisit(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @return Success
     */
    getPublicationStates(): Observable<PublicationStatus[]> {
        let url_ = this.baseUrl + "/api/publication-states";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPublicationStates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPublicationStates(<any>response_);
                } catch (e) {
                    return <Observable<PublicationStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublicationStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPublicationStates(response: HttpResponseBase): Observable<PublicationStatus[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PublicationStatus.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublicationStatus[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePublicationStatus(id: number, body: PublicationStatus | undefined): Observable<PublicationStatus> {
        let url_ = this.baseUrl + "/api/publication-states/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePublicationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePublicationStatus(<any>response_);
                } catch (e) {
                    return <Observable<PublicationStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<PublicationStatus>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePublicationStatus(response: HttpResponseBase): Observable<PublicationStatus> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PublicationStatus.fromJS(resultData200) : new PublicationStatus();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PublicationStatus>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<Role[]> {
        let url_ = this.baseUrl + "/api/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<Role[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<Role[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Role.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role[]>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param countryIds (optional) 
     * @param regionIds (optional) 
     * @return Success
     */
    getSpreadingGroups(page: number | undefined, pageSize: number | undefined, name: string | undefined, countryIds: number[] | undefined, regionIds: number[] | undefined): Observable<SpreadingGroupsPage> {
        let url_ = this.baseUrl + "/api/spreading-groups?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "countryIds=" + encodeURIComponent("" + item) + "&"; });
        if (regionIds === null)
            throw new Error("The parameter 'regionIds' cannot be null.");
        else if (regionIds !== undefined)
            regionIds && regionIds.forEach(item => { url_ += "regionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpreadingGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpreadingGroups(<any>response_);
                } catch (e) {
                    return <Observable<SpreadingGroupsPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpreadingGroupsPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpreadingGroups(response: HttpResponseBase): Observable<SpreadingGroupsPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpreadingGroupsPage.fromJS(resultData200) : new SpreadingGroupsPage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpreadingGroupsPage>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createSpreadingGroup(body: SpreadingGroup | undefined): Observable<SpreadingGroup> {
        let url_ = this.baseUrl + "/api/spreading-groups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSpreadingGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSpreadingGroup(<any>response_);
                } catch (e) {
                    return <Observable<SpreadingGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpreadingGroup>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSpreadingGroup(response: HttpResponseBase): Observable<SpreadingGroup> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpreadingGroup.fromJS(resultData200) : new SpreadingGroup();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpreadingGroup>(<any>null);
    }

    /**
     * @return Success
     */
    getSpreadingGroup(id: number): Observable<SpreadingGroup> {
        let url_ = this.baseUrl + "/api/spreading-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSpreadingGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSpreadingGroup(<any>response_);
                } catch (e) {
                    return <Observable<SpreadingGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpreadingGroup>><any>_observableThrow(response_);
        }));
    }

    protected processGetSpreadingGroup(response: HttpResponseBase): Observable<SpreadingGroup> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpreadingGroup.fromJS(resultData200) : new SpreadingGroup();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpreadingGroup>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSpreadingGroup(id: number, body: SpreadingGroup | undefined): Observable<SpreadingGroup> {
        let url_ = this.baseUrl + "/api/spreading-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSpreadingGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSpreadingGroup(<any>response_);
                } catch (e) {
                    return <Observable<SpreadingGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<SpreadingGroup>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSpreadingGroup(response: HttpResponseBase): Observable<SpreadingGroup> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SpreadingGroup.fromJS(resultData200) : new SpreadingGroup();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SpreadingGroup>(<any>null);
    }

    /**
     * @return Success
     */
    deleteSpreadingGroup(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/spreading-groups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSpreadingGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSpreadingGroup(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSpreadingGroup(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param page (optional) 
     * @param pageSize (optional) 
     * @param name (optional) 
     * @param surname (optional) 
     * @param lastSurname (optional) 
     * @param email (optional) 
     * @param location (optional) 
     * @param fromCreationDate (optional) 
     * @param toCreationDate (optional) 
     * @param roleIds (optional) 
     * @param countryIds (optional) 
     * @param regionIds (optional) 
     * @return Success
     */
    getUsers(page: number | undefined, pageSize: number | undefined, name: string | undefined, surname: string | undefined, lastSurname: string | undefined, email: string | undefined, location: string | undefined, fromCreationDate: Date | undefined, toCreationDate: Date | undefined, roleIds: number[] | undefined, countryIds: number[] | undefined, regionIds: number[] | undefined): Observable<UsersPage> {
        let url_ = this.baseUrl + "/api/users?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (surname === null)
            throw new Error("The parameter 'surname' cannot be null.");
        else if (surname !== undefined)
            url_ += "surname=" + encodeURIComponent("" + surname) + "&"; 
        if (lastSurname === null)
            throw new Error("The parameter 'lastSurname' cannot be null.");
        else if (lastSurname !== undefined)
            url_ += "lastSurname=" + encodeURIComponent("" + lastSurname) + "&"; 
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&"; 
        if (location === null)
            throw new Error("The parameter 'location' cannot be null.");
        else if (location !== undefined)
            url_ += "location=" + encodeURIComponent("" + location) + "&"; 
        if (fromCreationDate === null)
            throw new Error("The parameter 'fromCreationDate' cannot be null.");
        else if (fromCreationDate !== undefined)
            url_ += "fromCreationDate=" + encodeURIComponent(fromCreationDate ? "" + fromCreationDate.toJSON() : "") + "&"; 
        if (toCreationDate === null)
            throw new Error("The parameter 'toCreationDate' cannot be null.");
        else if (toCreationDate !== undefined)
            url_ += "toCreationDate=" + encodeURIComponent(toCreationDate ? "" + toCreationDate.toJSON() : "") + "&"; 
        if (roleIds === null)
            throw new Error("The parameter 'roleIds' cannot be null.");
        else if (roleIds !== undefined)
            roleIds && roleIds.forEach(item => { url_ += "roleIds=" + encodeURIComponent("" + item) + "&"; });
        if (countryIds === null)
            throw new Error("The parameter 'countryIds' cannot be null.");
        else if (countryIds !== undefined)
            countryIds && countryIds.forEach(item => { url_ += "countryIds=" + encodeURIComponent("" + item) + "&"; });
        if (regionIds === null)
            throw new Error("The parameter 'regionIds' cannot be null.");
        else if (regionIds !== undefined)
            regionIds && regionIds.forEach(item => { url_ += "regionIds=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UsersPage>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsersPage>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UsersPage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UsersPage.fromJS(resultData200) : new UsersPage();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsersPage>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createUser(body: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processCreateUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    getUser(id: number): Observable<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUser(id: number, body: User | undefined): Observable<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? User.fromJS(resultData200) : new User();
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = resultData400 ? ProblemDetails.fromJS(resultData400) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * @return Success
     */
    deleteUser(id: number): Observable<any> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticationRequest | undefined): Observable<AuthenticationResponse> {
        let url_ = this.baseUrl + "/api/users/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticationResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticationResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticationResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticationResponse.fromJS(resultData200) : new AuthenticationResponse();
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = resultData404 ? ProblemDetails.fromJS(resultData404) : new ProblemDetails();
            return throwException("A server error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticationResponse>(<any>null);
    }
}

export class AccessesPage implements IAccessesPage {
    accesses?: Access[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: IAccessesPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["accesses"] && data["accesses"].constructor === Array) {
                this.accesses = [] as any;
                for (let item of data["accesses"])
                    this.accesses!.push(Access.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): AccessesPage {
        data = typeof data === 'object' ? data : {};
        let result = new AccessesPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.accesses && this.accesses.constructor === Array) {
            data["accesses"] = [];
            for (let item of this.accesses)
                data["accesses"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface IAccessesPage {
    accesses?: Access[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class Access implements IAccess {
    id?: number;
    user?: User;
    date?: Date;

    constructor(data?: IAccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Access {
        data = typeof data === 'object' ? data : {};
        let result = new Access();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAccess {
    id?: number;
    user?: User;
    date?: Date;
}

export class User implements IUser {
    id?: number;
    name?: string;
    surname?: string;
    lastSurname?: string;
    mail?: string;
    role?: Role;
    region?: Region;
    picture?: Picture;
    location?: string;
    creationDate?: Date;
    functions?: Function[];
    phones?: Phone[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.lastSurname = data["lastSurname"];
            this.mail = data["mail"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.region = data["region"] ? Region.fromJS(data["region"]) : <any>undefined;
            this.picture = data["picture"] ? Picture.fromJS(data["picture"]) : <any>undefined;
            this.location = data["location"];
            this.creationDate = data["creationDate"] ? new Date(data["creationDate"].toString()) : <any>undefined;
            if (data["functions"] && data["functions"].constructor === Array) {
                this.functions = [] as any;
                for (let item of data["functions"])
                    this.functions!.push(Function.fromJS(item));
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [] as any;
                for (let item of data["phones"])
                    this.phones!.push(Phone.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["lastSurname"] = this.lastSurname;
        data["mail"] = this.mail;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["picture"] = this.picture ? this.picture.toJSON() : <any>undefined;
        data["location"] = this.location;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        if (this.functions && this.functions.constructor === Array) {
            data["functions"] = [];
            for (let item of this.functions)
                data["functions"].push(item.toJSON());
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    id?: number;
    name?: string;
    surname?: string;
    lastSurname?: string;
    mail?: string;
    role?: Role;
    region?: Region;
    picture?: Picture;
    location?: string;
    creationDate?: Date;
    functions?: Function[];
    phones?: Phone[];
}

export class Role implements IRole {
    id?: number;
    name?: string;
    defaultFunctions?: Function[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            if (data["defaultFunctions"] && data["defaultFunctions"].constructor === Array) {
                this.defaultFunctions = [] as any;
                for (let item of data["defaultFunctions"])
                    this.defaultFunctions!.push(Function.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (this.defaultFunctions && this.defaultFunctions.constructor === Array) {
            data["defaultFunctions"] = [];
            for (let item of this.defaultFunctions)
                data["defaultFunctions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    id?: number;
    name?: string;
    defaultFunctions?: Function[];
}

export class Region implements IRegion {
    id?: number;
    name?: string;
    code?: string;
    country?: Country;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.code = data["code"];
            this.country = data["country"] ? Country.fromJS(data["country"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        data["country"] = this.country ? this.country.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IRegion {
    id?: number;
    name?: string;
    code?: string;
    country?: Country;
}

export class Picture implements IPicture {
    id?: number;
    url?: string;

    constructor(data?: IPicture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): Picture {
        data = typeof data === 'object' ? data : {};
        let result = new Picture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["url"] = this.url;
        return data; 
    }
}

export interface IPicture {
    id?: number;
    url?: string;
}

export class Function implements IFunction {
    id?: number;
    name?: string;
    alias?: string;

    constructor(data?: IFunction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.alias = data["alias"];
        }
    }

    static fromJS(data: any): Function {
        data = typeof data === 'object' ? data : {};
        let result = new Function();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["alias"] = this.alias;
        return data; 
    }
}

export interface IFunction {
    id?: number;
    name?: string;
    alias?: string;
}

export class Phone implements IPhone {
    id?: number;
    countryCode?: string;
    number?: string;

    constructor(data?: IPhone) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.countryCode = data["countryCode"];
            this.number = data["number"];
        }
    }

    static fromJS(data: any): Phone {
        data = typeof data === 'object' ? data : {};
        let result = new Phone();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["countryCode"] = this.countryCode;
        data["number"] = this.number;
        return data; 
    }
}

export interface IPhone {
    id?: number;
    countryCode?: string;
    number?: string;
}

export class Country implements ICountry {
    id?: number;
    name?: string;
    code?: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.code = data["code"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data; 
    }
}

export interface ICountry {
    id?: number;
    name?: string;
    code?: string;
}

export class ProblemDetails implements IProblemDetails {
    type?: string;
    title?: string;
    status?: number;
    detail?: string;
    instance?: string;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.title = data["title"];
            this.status = data["status"];
            this.detail = data["detail"];
            this.instance = data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string;
    title?: string;
    status?: number;
    detail?: string;
    instance?: string;
}

export class AssociationLike implements IAssociationLike {
    id?: number;
    associationId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IAssociationLike) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.associationId = data["associationId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssociationLike {
        data = typeof data === 'object' ? data : {};
        let result = new AssociationLike();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["associationId"] = this.associationId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAssociationLike {
    id?: number;
    associationId?: number;
    date?: Date;
    user?: User;
}

export class AssociationsPage implements IAssociationsPage {
    associations?: Association[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: IAssociationsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["associations"] && data["associations"].constructor === Array) {
                this.associations = [] as any;
                for (let item of data["associations"])
                    this.associations!.push(Association.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): AssociationsPage {
        data = typeof data === 'object' ? data : {};
        let result = new AssociationsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.associations && this.associations.constructor === Array) {
            data["associations"] = [];
            for (let item of this.associations)
                data["associations"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface IAssociationsPage {
    associations?: Association[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class Association implements IAssociation {
    id?: number;
    name?: string;
    location?: string;
    region?: Region;
    emails?: string[];
    phones?: Phone[];
    pictures?: Picture[];
    members?: User[];

    constructor(data?: IAssociation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.location = data["location"];
            this.region = data["region"] ? Region.fromJS(data["region"]) : <any>undefined;
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [] as any;
                for (let item of data["emails"])
                    this.emails!.push(item);
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [] as any;
                for (let item of data["phones"])
                    this.phones!.push(Phone.fromJS(item));
            }
            if (data["pictures"] && data["pictures"].constructor === Array) {
                this.pictures = [] as any;
                for (let item of data["pictures"])
                    this.pictures!.push(Picture.fromJS(item));
            }
            if (data["members"] && data["members"].constructor === Array) {
                this.members = [] as any;
                for (let item of data["members"])
                    this.members!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Association {
        data = typeof data === 'object' ? data : {};
        let result = new Association();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["location"] = this.location;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.pictures && this.pictures.constructor === Array) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        if (this.members && this.members.constructor === Array) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAssociation {
    id?: number;
    name?: string;
    location?: string;
    region?: Region;
    emails?: string[];
    phones?: Phone[];
    pictures?: Picture[];
    members?: User[];
}

export class AssociationVisit implements IAssociationVisit {
    id?: number;
    associationId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IAssociationVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.associationId = data["associationId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssociationVisit {
        data = typeof data === 'object' ? data : {};
        let result = new AssociationVisit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["associationId"] = this.associationId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAssociationVisit {
    id?: number;
    associationId?: number;
    date?: Date;
    user?: User;
}

export class PetCategory implements IPetCategory {
    id?: number;
    name?: string;

    constructor(data?: IPetCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PetCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PetCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPetCategory {
    id?: number;
    name?: string;
}

export class PetContact implements IPetContact {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IPetContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.petId = data["petId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PetContact {
        data = typeof data === 'object' ? data : {};
        let result = new PetContact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["petId"] = this.petId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPetContact {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;
}

export class PetLike implements IPetLike {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IPetLike) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.petId = data["petId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PetLike {
        data = typeof data === 'object' ? data : {};
        let result = new PetLike();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["petId"] = this.petId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPetLike {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;
}

export class PetsPage implements IPetsPage {
    pets?: Pet[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: IPetsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pets"] && data["pets"].constructor === Array) {
                this.pets = [] as any;
                for (let item of data["pets"])
                    this.pets!.push(Pet.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): PetsPage {
        data = typeof data === 'object' ? data : {};
        let result = new PetsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pets && this.pets.constructor === Array) {
            data["pets"] = [];
            for (let item of this.pets)
                data["pets"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface IPetsPage {
    pets?: Pet[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class Pet implements IPet {
    id?: number;
    name?: string;
    age?: number;
    breed?: string;
    description?: string;
    location?: string;
    creationUtcDateTime?: Date;
    updateUtcDateTime?: Date;
    isAssociationFavorite?: boolean;
    rectifiedPetId?: number;
    type?: PetType;
    status?: PublicationStatus;
    category?: PetCategory;
    region?: Region;
    association?: Association;
    user?: User;
    pictures?: Picture[];
    href?: string;

    constructor(data?: IPet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.age = data["age"];
            this.breed = data["breed"];
            this.description = data["description"];
            this.location = data["location"];
            this.creationUtcDateTime = data["creationUtcDateTime"] ? new Date(data["creationUtcDateTime"].toString()) : <any>undefined;
            this.updateUtcDateTime = data["updateUtcDateTime"] ? new Date(data["updateUtcDateTime"].toString()) : <any>undefined;
            this.isAssociationFavorite = data["isAssociationFavorite"];
            this.rectifiedPetId = data["rectifiedPetId"];
            this.type = data["type"] ? PetType.fromJS(data["type"]) : <any>undefined;
            this.status = data["status"] ? PublicationStatus.fromJS(data["status"]) : <any>undefined;
            this.category = data["category"] ? PetCategory.fromJS(data["category"]) : <any>undefined;
            this.region = data["region"] ? Region.fromJS(data["region"]) : <any>undefined;
            this.association = data["association"] ? Association.fromJS(data["association"]) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            if (data["pictures"] && data["pictures"].constructor === Array) {
                this.pictures = [] as any;
                for (let item of data["pictures"])
                    this.pictures!.push(Picture.fromJS(item));
            }
            this.href = data["href"];
        }
    }

    static fromJS(data: any): Pet {
        data = typeof data === 'object' ? data : {};
        let result = new Pet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["age"] = this.age;
        data["breed"] = this.breed;
        data["description"] = this.description;
        data["location"] = this.location;
        data["creationUtcDateTime"] = this.creationUtcDateTime ? this.creationUtcDateTime.toISOString() : <any>undefined;
        data["updateUtcDateTime"] = this.updateUtcDateTime ? this.updateUtcDateTime.toISOString() : <any>undefined;
        data["isAssociationFavorite"] = this.isAssociationFavorite;
        data["rectifiedPetId"] = this.rectifiedPetId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["association"] = this.association ? this.association.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.pictures && this.pictures.constructor === Array) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        data["href"] = this.href;
        return data; 
    }
}

export interface IPet {
    id?: number;
    name?: string;
    age?: number;
    breed?: string;
    description?: string;
    location?: string;
    creationUtcDateTime?: Date;
    updateUtcDateTime?: Date;
    isAssociationFavorite?: boolean;
    rectifiedPetId?: number;
    type?: PetType;
    status?: PublicationStatus;
    category?: PetCategory;
    region?: Region;
    association?: Association;
    user?: User;
    pictures?: Picture[];
    href?: string;
}

export class PetType implements IPetType {
    id?: number;
    name?: string;

    constructor(data?: IPetType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PetType {
        data = typeof data === 'object' ? data : {};
        let result = new PetType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPetType {
    id?: number;
    name?: string;
}

export class PublicationStatus implements IPublicationStatus {
    id?: number;
    name?: string;

    constructor(data?: IPublicationStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): PublicationStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PublicationStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPublicationStatus {
    id?: number;
    name?: string;
}

export class PetVisit implements IPetVisit {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IPetVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.petId = data["petId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PetVisit {
        data = typeof data === 'object' ? data : {};
        let result = new PetVisit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["petId"] = this.petId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPetVisit {
    id?: number;
    petId?: number;
    date?: Date;
    user?: User;
}

export class ProfessionalServiceLike implements IProfessionalServiceLike {
    id?: number;
    professionalServiceId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IProfessionalServiceLike) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.professionalServiceId = data["professionalServiceId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfessionalServiceLike {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalServiceLike();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["professionalServiceId"] = this.professionalServiceId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProfessionalServiceLike {
    id?: number;
    professionalServiceId?: number;
    date?: Date;
    user?: User;
}

export class ProfessionalServicesPage implements IProfessionalServicesPage {
    professionalServices?: ProfessionalService[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: IProfessionalServicesPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["professionalServices"] && data["professionalServices"].constructor === Array) {
                this.professionalServices = [] as any;
                for (let item of data["professionalServices"])
                    this.professionalServices!.push(ProfessionalService.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): ProfessionalServicesPage {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalServicesPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.professionalServices && this.professionalServices.constructor === Array) {
            data["professionalServices"] = [];
            for (let item of this.professionalServices)
                data["professionalServices"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface IProfessionalServicesPage {
    professionalServices?: ProfessionalService[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class ProfessionalService implements IProfessionalService {
    id?: number;
    name?: string;
    creator?: User;
    association?: Association;
    isAssociationFavorite?: boolean;
    region?: Region;
    location?: string;
    status?: PublicationStatus;
    rectifiedProfessionalServiceId?: number;
    description?: string;
    emails?: string[];
    phones?: Phone[];
    pictures?: Picture[];
    types?: ProfessionalServiceType[];

    constructor(data?: IProfessionalService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creator = data["creator"] ? User.fromJS(data["creator"]) : <any>undefined;
            this.association = data["association"] ? Association.fromJS(data["association"]) : <any>undefined;
            this.isAssociationFavorite = data["isAssociationFavorite"];
            this.region = data["region"] ? Region.fromJS(data["region"]) : <any>undefined;
            this.location = data["location"];
            this.status = data["status"] ? PublicationStatus.fromJS(data["status"]) : <any>undefined;
            this.rectifiedProfessionalServiceId = data["rectifiedProfessionalServiceId"];
            this.description = data["description"];
            if (data["emails"] && data["emails"].constructor === Array) {
                this.emails = [] as any;
                for (let item of data["emails"])
                    this.emails!.push(item);
            }
            if (data["phones"] && data["phones"].constructor === Array) {
                this.phones = [] as any;
                for (let item of data["phones"])
                    this.phones!.push(Phone.fromJS(item));
            }
            if (data["pictures"] && data["pictures"].constructor === Array) {
                this.pictures = [] as any;
                for (let item of data["pictures"])
                    this.pictures!.push(Picture.fromJS(item));
            }
            if (data["types"] && data["types"].constructor === Array) {
                this.types = [] as any;
                for (let item of data["types"])
                    this.types!.push(ProfessionalServiceType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProfessionalService {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creator"] = this.creator ? this.creator.toJSON() : <any>undefined;
        data["association"] = this.association ? this.association.toJSON() : <any>undefined;
        data["isAssociationFavorite"] = this.isAssociationFavorite;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        data["location"] = this.location;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["rectifiedProfessionalServiceId"] = this.rectifiedProfessionalServiceId;
        data["description"] = this.description;
        if (this.emails && this.emails.constructor === Array) {
            data["emails"] = [];
            for (let item of this.emails)
                data["emails"].push(item);
        }
        if (this.phones && this.phones.constructor === Array) {
            data["phones"] = [];
            for (let item of this.phones)
                data["phones"].push(item.toJSON());
        }
        if (this.pictures && this.pictures.constructor === Array) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        if (this.types && this.types.constructor === Array) {
            data["types"] = [];
            for (let item of this.types)
                data["types"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProfessionalService {
    id?: number;
    name?: string;
    creator?: User;
    association?: Association;
    isAssociationFavorite?: boolean;
    region?: Region;
    location?: string;
    status?: PublicationStatus;
    rectifiedProfessionalServiceId?: number;
    description?: string;
    emails?: string[];
    phones?: Phone[];
    pictures?: Picture[];
    types?: ProfessionalServiceType[];
}

export class ProfessionalServiceType implements IProfessionalServiceType {
    id?: number;
    name?: string;

    constructor(data?: IProfessionalServiceType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): ProfessionalServiceType {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalServiceType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IProfessionalServiceType {
    id?: number;
    name?: string;
}

export class ProfessionalServiceVisit implements IProfessionalServiceVisit {
    id?: number;
    professionalServiceId?: number;
    date?: Date;
    user?: User;

    constructor(data?: IProfessionalServiceVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.professionalServiceId = data["professionalServiceId"];
            this.date = data["date"] ? new Date(data["date"].toString()) : <any>undefined;
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProfessionalServiceVisit {
        data = typeof data === 'object' ? data : {};
        let result = new ProfessionalServiceVisit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["professionalServiceId"] = this.professionalServiceId;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProfessionalServiceVisit {
    id?: number;
    professionalServiceId?: number;
    date?: Date;
    user?: User;
}

export class SpreadingGroupsPage implements ISpreadingGroupsPage {
    spreadingGroups?: SpreadingGroup[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: ISpreadingGroupsPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["spreadingGroups"] && data["spreadingGroups"].constructor === Array) {
                this.spreadingGroups = [] as any;
                for (let item of data["spreadingGroups"])
                    this.spreadingGroups!.push(SpreadingGroup.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): SpreadingGroupsPage {
        data = typeof data === 'object' ? data : {};
        let result = new SpreadingGroupsPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.spreadingGroups && this.spreadingGroups.constructor === Array) {
            data["spreadingGroups"] = [];
            for (let item of this.spreadingGroups)
                data["spreadingGroups"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface ISpreadingGroupsPage {
    spreadingGroups?: SpreadingGroup[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class SpreadingGroup implements ISpreadingGroup {
    id?: number;
    name?: string;
    region?: Region;

    constructor(data?: ISpreadingGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.region = data["region"] ? Region.fromJS(data["region"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SpreadingGroup {
        data = typeof data === 'object' ? data : {};
        let result = new SpreadingGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["region"] = this.region ? this.region.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISpreadingGroup {
    id?: number;
    name?: string;
    region?: Region;
}

export class UsersPage implements IUsersPage {
    users?: User[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;

    constructor(data?: IUsersPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [] as any;
                for (let item of data["users"])
                    this.users!.push(User.fromJS(item));
            }
            this.total = data["total"];
            this.page = data["page"];
            this.pageSize = data["pageSize"];
            this.numberOfPages = data["numberOfPages"];
        }
    }

    static fromJS(data: any): UsersPage {
        data = typeof data === 'object' ? data : {};
        let result = new UsersPage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageSize"] = this.pageSize;
        data["numberOfPages"] = this.numberOfPages;
        return data; 
    }
}

export interface IUsersPage {
    users?: User[];
    total?: number;
    page?: number;
    pageSize?: number;
    numberOfPages?: number;
}

export class AuthenticationRequest implements IAuthenticationRequest {
    mail?: string;
    password?: string;
    type?: AuthenticationRequestType;

    constructor(data?: IAuthenticationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mail = data["mail"];
            this.password = data["password"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): AuthenticationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mail"] = this.mail;
        data["password"] = this.password;
        data["type"] = this.type;
        return data; 
    }
}

export interface IAuthenticationRequest {
    mail?: string;
    password?: string;
    type?: AuthenticationRequestType;
}

export class AuthenticationResponse implements IAuthenticationResponse {
    user?: User;
    token?: string;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.token = data["token"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["token"] = this.token;
        return data; 
    }
}

export interface IAuthenticationResponse {
    user?: User;
    token?: string;
}

export enum AuthenticationRequestType {
    Vanilla = "Vanilla", 
    Facebook = "Facebook", 
    Twitter = "Twitter", 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}
